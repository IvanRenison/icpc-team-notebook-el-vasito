%"The PDF file may contain up to 25 pages of reference material, single-sided, letter or A4 size, with text and illustrations readable by a person with correctable eyesight without magnification from a distance of 1/2 meter."
\input{preamble.tex}
\begin{document}

\UseRawInputEncoding
\def\title{Universidad Nacional de Córdoba - Gracias Mateo}
.\\[0.2cm]
\centering{\LARGE\textbf{Gracias Mateo}} \\[0.5cm]
\centering{\includegraphics[width=5.5cm]{img/vasito.jpg}}
\tableofcontents\newpage

\section{Data structures}
\subsection{Segment tree}
\cppfile{data_structures/segment_tree.cpp}
\subsection{Segment tree - Iterative}
\cppfile{data_structures/segment_tree_iterative.cpp}
\subsection{Segment tree - Lazy propagation}
\cppfile{data_structures/segment_tree_lazy.cpp}
\subsection{Segment tree - Persistence}
\cppfile{data_structures/segment_tree_persistent.cpp}
\subsection{Segment tree - 2D}
\cppfile{data_structures/segment_tree_2d.cpp}
\subsection{Sparse table (static RMQ)}
\cppfile{data_structures/sparse_table.cpp}
\subsection{Fenwick tree}
\cppfile{data_structures/fenwick_tree.cpp}
\subsection{Wavelet tree}
\cppfile{data_structures/wavelet_tree.cpp}
\subsection{STL extended set}
\cppfile{data_structures/stl_extended_set.cpp}
\subsection{STL rope}
\cppfile{data_structures/stl_rope.cpp}
\subsection{Treap (as BST)}
\cppfile{data_structures/treap.cpp}
\subsection{Treap (implicit key)}
\cppfile{data_structures/treap_implicit.cpp}
\subsection{Treap (with node father)}
\cppfile{data_structures/treap_implicit_father.cpp}
\subsection{Link-Cut tree}
\cppfile{data_structures/link_cut_tree.cpp}
\subsection{Link-Cut tree 2}
\cppfile{data_structures/linkcut2.cpp}
\subsection{Convex hull trick (static)}
\cppfile{data_structures/convexhull_trick.cpp}
\subsection{Convex hull trick (dynamic)}
\cppfile{data_structures/convexhull_trick_dynamic.cpp}
\subsection{Gain-cost-set}
\cppfile{data_structures/gain_cost_set.cpp}
\subsection{RMQ construcción O(n) y query O(1)}
\cppfile{data_structures/rmq_constant.cpp}
\subsection{Disjoint intervals}
\cppfile{data_structures/disjoint_intervals.cpp}

\section{Graphs}
\subsection{Topological sort}
\cppfile{graphs/toposort.cpp}
\subsection{Kruskal (+ Union-Find)}
\cppfile{graphs/kruskal.cpp}
\subsection{Dijkstra}
\cppfile{graphs/dijkstra.cpp}
\subsection{Bellman-Ford}
\cppfile{graphs/bellman_ford.cpp}
\subsection{Floyd-Warshall}
\cppfile{graphs/floyd_warshall.cpp}
\subsection{Strongly connected components (+ 2-SAT)}
\cppfile{graphs/tarjan_2sat.cpp}
\subsection{Articulation - Bridges - Biconnected}
\cppfile{graphs/articulation_bridges_biconnected.cpp}
\subsection{Chu-Liu (minimum spanning arborescence)}
\cppfile{graphs/chu_liu.cpp}
\subsection{LCA - Binary Lifting}
\cppfile{graphs/lca.cpp}
\subsection{Heavy-Light decomposition}
\cppfile{graphs/hld.cpp}
\subsection{Centroid decomposition}
\cppfile{graphs/centroid.cpp}
\subsection{Parallel DFS}
\cppfile{graphs/parallel_dfs.cpp}
\subsection{Eulerian path}
\cppfile{graphs/eulerian_path.cpp}
\subsection{Dynamic connectivity}
\cppfile{graphs/dynamic_connectivity.cpp}
\subsection{Edmond's blossom (matching in general graphs)}
\cppfile{graphs/edmonds_blossom.cpp}
\subsection{Dominator tree}
\cppfile{graphs/dominator_tree.cpp}
\subsection{Rerooting DP}
\cppfile{graphs/rerooting.cpp}
\subsection{Tree DSU}
\cppfile{graphs/tree_dsu.cpp}
\subsection{Edge coloring bipartite}
\cppfile{graphs/edge_color.cpp}

\section{Math}
\subsection{Identities}
{
	$C_n = \frac{2(2n-1)}{n+1} C_{n-1}$

	$C_n = \frac{1}{n+1} \binom{2n}{n}$

	$C_n \sim \frac{4^n}{n^{3/2}\sqrt{\pi}}$

	$\sigma(n) = O(\log(\log(n)))$ (number of divisors of $n$)

	$F_{2n+1} = F_{n}^2 + F_{n+1}^2$

	$F_{2n} = F_{n+1}^2 - F_{n-1}^2$

	$\sum_{i=1}^n F_i = F_{n+2}-1$

	$F_{n+i}F_{n+j} - F_nF_{n+i+j} = (-1)^n F_iF_j$

	(Möbius Inv. Formula)
	Let $g(n) = \sum_{d\mid n} f(d)$, then $f(n)=\sum{d\mid n} g(d) \mu\left(\frac{n}{d})\right)$.
}
\subsection{Theorems and Formulas}
\input{math/formulas.tex}
\subsection{Theorems}
\cppfile{math/theorems.txt}
\subsection{Integer floor division}
\cppfile{math/floor_division.cpp}
%\subsection{Extended Euclid} % allready in diophantine
%\cppfile{math/extended_euclid.cpp}
\subsection{Sieve of Eratosthenes}
\cppfile{math/sieve.cpp}
\subsection{Generate divisors}
\cppfile{math/divisors.cpp}
\subsection{Pollard's rho}
\cppfile{math/pollard_rho.cpp}
\subsection{Simpson's rule}
\cppfile{math/simpson.cpp}
\subsection{Polynomials}
\cppfile{math/polynomial.cpp}
\subsection{Bairstow}
\cppfile{math/bairstow.cpp}
\subsection{Fast Fourier Transform}
\cppfile{math/fft.cpp}
\subsection{Fast Fourier Transform Operations}
\cppfile{math/fft_operations.cpp}
\subsection{Fast Hadamard Transform}
\cppfile{math/fht.cpp}
\subsection{Karatsuba}
\cppfile{math/karatsuba.cpp}
\subsection{Diophantine}
\cppfile{math/diophantine.cpp}
\subsection{Modular inverse}
\cppfile{math/inversemod.cpp}
\subsection{Chinese remainder theorem}
\cppfile{math/crt.cpp}
\subsection{Mobius}
\cppfile{math/mobius.cpp}
\subsection{Matrix exponentiation}
\cppfile{math/matrix_fast_pow.cpp}
\subsection{Matrix reduce and determinant}
\cppfile{math/matrix_reduce.cpp}
\subsection{Simplex}
\cppfile{math/simplex.cpp}
\subsection{Discrete log}
\cppfile{math/discrete_log.cpp}
\subsection{Berlekamp Massey}
\cppfile{math/berlekamp_massey.cpp}
\subsection{Linear Rec}
\cppfile{math/linear_rec.cpp}
\subsection{Tonelli Shanks}
\cppfile{math/tonelli_shanks.cpp}
\subsection{Points Under Line}
\cppfile{math/points_under_line.cpp}

\section{Geometry}
\subsection{Point}
\cppfile{geometry/point.cpp}
\subsection{Line}
\cppfile{geometry/line.cpp}
\subsection{Circle}
\cppfile{geometry/circle.cpp}
\subsection{Polygon}
\cppfile{geometry/polygon.cpp}
\subsection{Plane}
\cppfile{geometry/plane.cpp}
\subsection{Radial order of points}
\cppfile{geometry/radial_order.cpp}
\subsection{Convex hull}
\cppfile{geometry/convex_hull.cpp}
\subsection{Dual from planar graph}
\cppfile{geometry/planar_graph_dual.cpp}
\subsection{Halfplane intersection}
\cppfile{geometry/halfplanes.cpp}
\subsection{KD Tree}
\cppfile{geometry/kdtree.cpp}
\subsection{Closest points}
\cppfile{geometry/closest.cpp}
\subsection{Theorems and Formulas}
\input{geometry/formulas.tex}

\section{Strings}
\subsection{KMP}
\cppfile{strings/kmp.cpp}
\subsection{Z function}
\cppfile{strings/z_function.cpp}
\subsection{Hashing}
\cppfile{strings/hashing_128.cpp}
\subsection{Manacher}
\cppfile{strings/manacher.cpp}
\subsection{Aho-Corasick}
\cppfile{strings/aho_corasick.cpp}
\subsection{Suffix automaton}
\cppfile{strings/suffix_automaton.cpp}
\subsection{Palindromic Tree}
\cppfile{strings/palindromic_tree.cpp}
\subsection{Suffix array (shorter but slower)}
\cppfile{strings/suffix_array_slow.cpp}
\subsection{Suffix array}
\cppfile{strings/suffix_array.cpp}
\subsection{LCP (Longest Common Prefix)}
\cppfile{strings/lcp.cpp}
\subsection{Suffix Tree (Ukkonen's algorithm)}
\cppfile{strings/suffix_tree.cpp}
\subsection{Hashing}
\cppfile{strings/hashing.cpp}
\subsection{Hashing with ll (using \_\_int128)}
\cppfile{strings/hashing_128.cpp}
\subsection{Minimum Lexicographic rotation}
\cppfile{strings/get_min_lex.cpp}

\section{Flow}
\subsection{Matching (slower, O(n\textsuperscript{2}))}
\cppfile{flow/matching.cpp}
\subsection{Matching (Hopcroft-Karp)}
\cppfile{flow/hopcroft_karp.cpp}
\subsection{Hungarian}
\cppfile{flow/hungarian.cpp}
\subsection{Dinic}
\cppfile{flow/dinic.cpp}
\subsection{Min cost max flow}
\cppfile{flow/min_cost_max_flow.cpp}
\subsection{Min cost max flow cycles}
\cppfile{flow/min_cost_max_flow_cycle.cpp}

\subsection{Useful stuff}

\begin{itemize}
	\item \# of disjoint s-t paths = min-cut
	\item $\forall X: |Vecinos(X)| >= |X| \iff$ perfect matching
	\item $|\text{Largest antichain}|$ = $|\text{smallest chain decomposition}|$
	\item $|Max Matching| = |min Vertex Cover|$
	\item Rebuild cover $(A-Z)\cup(B\cap Z)$ Z = unmatched from $L$ + reachable by alternating paths
	\begin{code}
	vector<bool> L, R;
	void dfs2(int x, int part) {
		if(!part&&L[x]){L[x]=0;for(auto v:g[x])dfs2(v,!part);}
		else if(part&&!R[x])R[x]=1,dfs2(mt[x],!part);
	}
	void cover() {L.assign(n, 1); R.assign(m, 0);
		fore(i,0,n)if(mt2[i]<0)dfs2(i,0);
	}\end{code}
	\item Vertices in all matchings. Orient matched edges L->R, and others R->L, $v$ can be omitted if:
		\begin{itemize}
			\item v is unmatched
			\item v can be reached from an unmatched vertex ON ITS SIDE
			\item v can reach an unmatched vertex ON ITS SIDE
		\end{itemize}
	\item Circulation with demands
	\begin{itemize}
		\item add new source $s$ and sink $t$
		\item if $d(v) < 0$, $add\_edge(s, v, -d(v))$
		\item if $d(v) > 0$, $add\_edge(v, t, d(v))$
		\item There is circulation if the all s,t arcs saturate
	\end{itemize}
	\item Circulation with demans and lowerbounds ($l$)
	\begin{itemize}
		\item new $cap(e)$ = $cap(e)$ - $l(e)$
		\item new $d(v)$ = $d(v)$ + sum of $l(e)$ out - sum of $l(e)$ in
	\end{itemize}
\end{itemize}

\section{Other}
\subsection{Mo's algorithm}
\cppfile{other/mos_algorithm.cpp}
\subsection{Divide and conquer DP optimization}
\cppfile{other/divide_and_conquer_dp.cpp}
\subsection{Dates}
\cppfile{other/dates.cpp}
\subsection{C++ stuff}
\cppfile{other/cpp_stuff.cpp}
\subsection{Problem tester template}
\pyfile{other/tester.py}
\subsection{Interactor command}
\shfile{other/program_interaction.sh}
\subsection{Template}
\cppfile{other/template.cpp}

\subsection{Max number of divisors up to 10\textsuperscript{n}}
\cppfile{other/hcn.txt}
\subsection{Highly composite numbers}
\cppfile{other/hcn_all.txt}

\subsection{Ideas}
Meet in the Middle; Gauss Elimination (Z\_p); Interpolate; Centroid; HLD;
SQRT/Mos; Biconnected/AP/Bridge; Matrix Exp; Offline; D\&C; EulerTour;
DP Optimization(Aliens,Knuth,etc); SparseTable; Strings; 2SAT;
Brute Force; 2\^k jumps;
Small-to-large;randomize;ver diferencias;berlekamp;

!!! INICIALIZAR, REVISAR COMENTARIOS, COTAS, INT128/LL, VER N=1 !!!


\end{document}
